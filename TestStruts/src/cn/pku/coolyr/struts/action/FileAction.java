/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package cn.pku.coolyr.struts.action;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.upload.FormFile;

import cn.pku.coolyr.struts.form.FileActionForm;

/**
 * MyEclipse Struts Creation date: 12-22-2015
 * 
 * XDoclet definition:
 * 
 * @struts.action path="/file" name="fileActionForm" parameter="flag"
 *                scope="request" validate="true"
 */
public class FileAction extends Action
{
//	private JDBConnection connection = new JDBConnection();

	// 以下方法实现文件的上传
	public ActionForward upLoadFile(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
	{
		ActionForward forward = null;
		Date date = new Date();
		FileActionForm fileActionForm = (FileActionForm) form;
		// FormFile用于指定存取文件的类型
		FormFile file = fileActionForm.getFile(); // 获取当前的文件
		// 获得系统的绝对路径 String dir =
		// servlet.getServletContext().getRealPath("/image");
		// 我上传的文件没有放在服务器上。而是存在D:D:\\loadfile\\temp\\
		String dir = "D:\\loadfile\\temp\\";
		int i = 0;
		String type = file.getFileName();
		while (i != -1)
		{
			// 找到上传文件的类型的位置，这个地方的是'.'
			i = type.indexOf(".");
			/* System.out.println(i); */
			/* 截取上传文件的后缀名,此时得到了文件的类型 */
			type = type.substring(i + 1);
		}
		// 限制上传类型为jpg,txt,rar;
		if (!type.equals("jpg") && !type.equals("txt") && !type.equals("bmp"))

		{// 当上传的类型不为上述类型时，跳转到错误页面。
			forward = mapping.findForward("error");
		}
		else
		{
			// 将上传时间加入文件名（这个地方的是毫秒数）
			String times = String.valueOf(date.getTime());
			// 组合成 time.type
			String fname = times + "." + type;
			// InInputStream是用以从特定的资源读取字节的方法。
			InputStream streamIn = file.getInputStream(); // 创建读取用户上传文件的对象
			// 得到是字节数，即byte,我们可以直接用file.getFileSize(),也可以在创建读取对象时用streamIn.available();
			// int ok=streamIn.available();
			int ok = file.getFileSize();
			String strFee = null;
			// 这个地方是处理上传的为M单位计算时，下一个是以kb,在下一个是byte;

			if (ok >= 1024 * 1024)
			{
				float ok1 = (((float) ok) / 1024f / 1024f);
				DecimalFormat myformat1 = new DecimalFormat("0.00");
				strFee = myformat1.format(ok1) + "M";
				System.out.println(strFee + "M");
			}
			else if (ok > 1024 && ok <= 1024 * 1024)
			{
				double ok2 = ((double) ok) / 1024;
				DecimalFormat myformat2 = new DecimalFormat("0.00");
				strFee = myformat2.format(ok2) + "kb";
				System.out.println(strFee + "kb");
			}
			else if (ok < 1024)
			{
				System.out.println("aaaaaaaaa");
				strFee = String.valueOf(ok) + "byte";
				System.out.println(strFee);

			}
			System.out.println(streamIn.available() + "文件大小byte");
			// 这个是io包下的上传文件类
			File uploadFile = new File(dir); // 指定上传文件的位置
			if (!uploadFile.exists() || uploadFile == null)
			{ // 判断指定路径dir是否存在，不存在则创建路径
				uploadFile.mkdirs();
			}
			// 上传的路径+文件名
			String path = uploadFile.getPath() + "\\" + fname;
			// OutputStream用于向某个目标写入字节的抽象类，这个地方写入目标是path，通过输出流FileOutputStream去写
			OutputStream streamOut = new FileOutputStream(path);
			int bytesRead = 0;
			byte[] buffer = new byte[8192];
			// 将数据读入byte数组的一部分，其中读入字节数的最大值是8192，读入的字节将存储到，buffer[0]到buffer[0+8190-1]的部分中
			// streamIn.read方法返回的是实际读取字节数目.如果读到末尾则返回-1.如果bytesRead返回为0则表示没有读取任何字节。
			while ((bytesRead = streamIn.read(buffer, 0, 8192)) != -1)
			{
				// 写入buffer数组的一部分，从buf[0]开始写入并写入bytesRead个字节，这个write方法将发生阻塞直至字节写入完成。
				streamOut.write(buffer, 0, bytesRead);
			}
			// 关闭输出输入流,销毁File流。
			streamOut.close();
			streamIn.close();
			file.destroy();
			String paths = path;
			System.out.println(paths);
//			String fileName = Chinese.toChinese(fileActionForm.getFileName()); // 获取文件的名称
//			// String fileSize = String.valueOf(file.getFileSize());
//			String fileDate = DateFormat.getDateInstance().format(date);
//			String sql = "insert into tb_file values('" + fileName + "','" + strFee + "','" + fileDate + "','" + paths + "')";
//			connection.executeUpdate(sql);
//			connection.closeConnection();
			forward = mapping.findForward("upLoadFileResult");
		}
		return forward;
	}

	// 实现文件的下载
	public ActionForward downFile(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
	{
		String path = request.getParameter("path");
		System.out.println(path + "111");
		BufferedInputStream bis = null;
		BufferedOutputStream bos = null;
		OutputStream fos = null;
		InputStream fis = null;

		// 如果是从服务器上取就用这个获得系统的绝对路径方法。 String filepath =
		// servlet.getServletContext().getRealPath("/" + path);
		String filepath = path;
		System.out.println("文件路径" + filepath);
		File uploadFile = new File(filepath);
		fis = new FileInputStream(uploadFile);
		bis = new BufferedInputStream(fis);
		fos = response.getOutputStream();
		bos = new BufferedOutputStream(fos);
		// 这个就就是弹出下载对话框的关键代码
		response.setHeader("Content-disposition", "attachment;filename=" + URLEncoder.encode(path, "utf-8"));
		int bytesRead = 0;
		// 这个地方的同上传的一样。我就不多说了，都是用输入流进行先读，然后用输出流去写，唯一不同的是我用的是缓冲输入输出流
		byte[] buffer = new byte[8192];
		while ((bytesRead = bis.read(buffer, 0, 8192)) != -1)
		{
			bos.write(buffer, 0, bytesRead);
		}
		bos.flush();
		fis.close();
		bis.close();
		fos.close();
		bos.close();
		return null;
	}
}